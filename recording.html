<!DOCTYPE html>
<html lang="en">

<head>
    <title>RecordRTC</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">

    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3" crossorigin="anonymous">
    
    <link rel="stylesheet" href="assets/css/style.css">
    <link rel="stylesheet" href="assets/css/media.css">
    
    <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.10.2/dist/umd/popper.min.js" integrity="sha384-7+zCNj/IqJ95wo16oMtfsKbZ9ccEh31eOz1HGyDuCQ6wgnyJNSYdrPa03rtR1zdB" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.min.js" integrity="sha384-QJHtvGhmr9XOIpI6YVutG+2QOK9T+ZnN4kzFN1RtK3zEFEIsxhlmWl5/YESvpZ13" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js" integrity="sha384-ka7Sk0Gln4gmtz2MlQnikT1wXgYsOg+OMhuP+IlRH9sENBO0LRn5q+8nbTov4+1p" crossorigin="anonymous"></script>

    <script src="node_modules/recordrtc/RecordRTC.js"></script>
    <script src="assets/js/media.js"></script>
    
    <script src="https://unpkg.com/@mattiasbuelens/web-streams-polyfill/dist/polyfill.min.js"></script>
    <script src="https://www.webrtc-experiment.com/EBML.js"></script>
    <script src="https://webrtc.github.io/adapter/adapter-latest.js"></script>
    <script src="https://www.webrtc-experiment.com/DetectRTC.js"> </script>
</head>

<body>
    <main class="container my-5">
        <form id="selectors" class="mb-5">
            <div class="row">
                <div class="col">
                    <label for="media-sound" class="form-label">Sound</label>
                    <select id="media-sound" class="form-select">
                        <option value="with-sound" selected>With Sound</option>
                        <option value="without-sound">Without Sound</option>
                    </select>
                </div>

                <div class="col">
                    <label for="media-resolution" class="form-label">Resolution</label>
                    <select id="media-resolution" class="form-select">
                        <option value="default" selected>Default</option>
                        <option value="3840x2160">4K     </option>
                        <option value="1920x1080">1080p  </option>
                        <option value="1280x720"> 720p   </option>
                        <option value="640x480">  480p   </option>
                    </select>
                </div>

                <div class="col">
                    <label for="media-framerate" class="form-label">Framerate</label>
                    <select id="media-framerate" class="form-select">
                        <option value="default" selected>Default</option>
                        <option value="60">60 fps</option>
                        <option value="30">30 fps</option>
                        <option value="24">24 fps</option>
                        <option value="15">15 fps</option>
                        <option value="5"> 5 fps </option>
                    </select>
                </div>

                <div class="col">
                    <label for="media-resolution" class="form-label">Bitrate</label>
                    <select id="media-bitrate" class="form-select">
                        <option value="default" selected>Default</option>
                        <option value="8000000000">1 GB/s  </option>
                        <option value="800000000"> 100 MB/s</option>
                        <option value="80000000">  10 MB/s </option>
                        <option value="8000000">   1 MB/s  </option>
                        <option value="800000">    100 KB/s</option>
                        <option value="80000">     10 KB/s </option>
                        <option value="8000">      1 KB/s  </option>
                        <option value="800">       100 B/s </option>
                    </select>
                </div>

                <div class="col">
                    <label for="media-format" class="form-label">Format</label>
                    <select id="media-format" class="form-select">
                        <option value="default" selected>Default</option>
                    </select>
                </div>
            </div>
        </form>

        <div id="playback-area">
            <div id="recording-player" class="mb-5 d-flex justify-content-center"></div>

            <form class="d-flex justify-content-center">
                <button id="btn-start"    class="btn btn-success"                      >Start   </button>
                <button id="btn-download" class="btn btn-primary" style="display: none">Download</button>
                <button id="btn-upload"   class="btn btn-warning" style="display: none">Upload  </button>
            </form>
        </div>
    </main>

    <script> // Global variables
        const MY_DOMAIN = 'webrtc-experiment.com' // TODO

        var mimeType      = 'video/webm'
        var fileExtension = 'webm'
        var type          = 'video'

        var recorderType
        var defaultWidth
        var defaultHeight

        var media_bitrate
    </script>

    <script> // Helper functions
        (function() {
            var params = {}
            var regex = /([^&=]+)=?([^&]*)/g

            function d(s) {
                return decodeURIComponent(s.replace(/\+/g, ' '))
            }

            var match, search = window.location.search

            while (match = regex.exec(search.substring(1))) {
                params[d(match[1])] = d(match[2]);

                if (d(match[2]) === 'true' || d(match[2]) === 'false') {
                    params[d(match[1])] = (d(match[2]) === 'true')
                }
            }

            window.params = params;
        })()


        function formatBytes(bytes, decimals = 2, k = 1024) {
            if (bytes == 0) return "0 Bytes"

            let sizes = ["Bytes", "KB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"]

            let d = Math.floor(Math.log(bytes) / Math.log(k))
            let c = parseFloat((bytes / Math.pow(k, d)).toFixed(Math.max(0, decimals)))

            return `${c} ${sizes[d]}`
        }


        function stringify(obj) {
            var result = ''

            Object.keys(obj).forEach(function(key) {
                if (typeof obj[key] === 'function') return

                if (result.length) {
                    result += ','
                }

                result += key + ': ' + obj[key]
            })

            return result
        }


        function addStreamStopListener(stream, callback) {
            stream.addEventListener('ended', function() {
                callback();
                callback = function() {};
            }, false)

            stream.addEventListener('inactive', function() {
                callback();
                callback = function() {};
            }, false)

            stream.getTracks().forEach(function(track) {
                track.addEventListener('ended', function() {
                    callback();
                    callback = function() {};
                }, false)

                track.addEventListener('inactive', function() {
                    callback();
                    callback = function() {};
                }, false)
            })
        }
    
        
        function isMimeTypeSupported(mimeType) {
            if (typeof MediaRecorder === 'undefined') {
                return false
            }

            if (typeof MediaRecorder.isTypeSupported !== 'function') {
                return true
            }

            return MediaRecorder.isTypeSupported(mimeType);
        } // END function isMimeTypeSupported
    

        function makeFileName(fileExtension) {
            var d = new Date().toISOString()
                .replace(/:/g, '-').replace(/\./g, '-')
                .replace(/T/g, '_').replace(/Z/g, '')

            return `ScreenRecord_${d}.${fileExtension}`
        } // END function makeFileName
    
    
        function isMyOwnDomain() {
            return document.domain.indexOf(MY_DOMAIN) !== -1;
        } // END function isMyOwnDomain


        function isLocalHost() {
            return document.domain === 'localhost' || document.domain === '127.0.0.1';
        } // END function isLocalHost


        function mediaRecorderToStringify(mediaRecorder) {
            var result = `
                mimeType: ${mediaRecorder.mimeType},
                state: ${mediaRecorder.state},
                audioBitsPerSecond: ${mediaRecorder.audioBitsPerSecond},
                media_bitrate: ${mediaRecorder.media_bitrate}`

            if (mediaRecorder.stream) {
                result += `,
                    streamid: ${mediaRecorder.stream.id},
                    stream-active: ${mediaRecorder.stream.active}`
            }

            return result
        } // END function mediaRecorderToStringify
    
    
        function getURL(arg) {
            if (arg instanceof Blob || arg instanceof File) {
                return URL.createObjectURL(arg);
            } else if (arg instanceof RecordRTC || arg.getBlob) {
                return URL.createObjectURL(arg.getBlob());
            } else {
                return arg
            }
        } // END function getURL
    </script>

    <script> // Creating HTML Elements
        var video = document.createElement('video')

        var media_element = getHTMLMediaElement(video, {
            title: 'Recording inactive',
            buttons: ['full-screen'],
            showOnMouseEnter: false,
            // width: 720,
        })

        media_element.id = 'media-element'

        document.getElementById('recording-player').appendChild(media_element)

        var media_element_container = document.createElement('section')

        media_element.media.muted = false // video
        media_element.media.autoplay = true
        media_element.media.playsinline = true
        media_element.media.id = 'media-element-media'
        media_element_container.id = 'media-element-container'

        media_element.media.parentNode.appendChild(media_element_container)
        media_element_container.appendChild(media_element.media)

        function initFormats() {
            var filetype_options = []

            var checks = [
                [isMimeTypeSupported('video/webm\;codecs=h264'),      'mp4'        ],
                [isMimeTypeSupported('video/x-matroska;codecs=avc1'), 'mkv'        ],
                [true,                                                'vp8'        ],
                [isMimeTypeSupported('video/webm\;codecs=vp9'),       'vp9'        ],
                [true,                                                'gif'        ],
                [DetectRTC.browser.name == 'Chrome',                  'whammy'     ],
                [DetectRTC.browser.name == 'Chrome',                  'WebAssembly'],
            ]

            checks.forEach(function (check) {
                if (check[0]) filetype_options.push(check[1])
            })

            setMediaContainerFormat(filetype_options)
        }
    
    
        function setGetFromLocalStorage(selectors) {
            selectors.forEach(function(selector) {
                var storageItem = selector.replace(/\.|#/g, '');

                if (localStorage.getItem(storageItem)) {
                    document.querySelector(selector).value = localStorage.getItem(storageItem);
                }

                addEventListenerToUploadLocalStorageItem(selector, ['change', 'blur'], function() {
                    localStorage.setItem(storageItem, document.querySelector(selector).value);
                })
            })
        } // END function setGetFromLocalStorage

    </script>

    <script> // Capture Functions
        function captureScreen(config) {
            if (navigator.getDisplayMedia) {
                navigator.getDisplayMedia({
                    video: true
                }).then(screenStream => {
                    config.onMediaCaptured(screenStream);

                    addStreamStopListener(screenStream, function() {
                        btnStart.onclick();
                    });

                    setVideoURL(screenStream, true);
                }).catch(function(error) {
                    config.onMediaCapturingFailed(error);
                });
            } else if (navigator.mediaDevices.getDisplayMedia) {
                navigator.mediaDevices.getDisplayMedia({
                    video: true
                }).then(screenStream => {
                    config.onMediaCaptured(screenStream);

                    addStreamStopListener(screenStream, function() {
                        btnStart.onclick();
                    });

                    setVideoURL(screenStream, true);
                }).catch(function(error) {
                    config.onMediaCapturingFailed(error);
                });
            } else {
                var error = 'getDisplayMedia API are not supported in this browser.';
                config.onMediaCapturingFailed(error);
                alert(error);
            }
        }

        function captureAudioPlusScreen(config) {
            if (navigator.getDisplayMedia) {
                navigator.getDisplayMedia({
                    video: true
                }).then(screenStream => {
                    navigator.mediaDevices.getUserMedia({audio:true}).then(function(mic) {
                        screenStream.addTrack(mic.getTracks()[0]);

                        config.onMediaCaptured(screenStream);

                        addStreamStopListener(screenStream, function() {
                            btnStart.onclick();
                        });

                        setVideoURL(screenStream, true);
                    });
                }).catch(function(error) {
                    config.onMediaCapturingFailed(error);
                });
            } else if (navigator.mediaDevices.getDisplayMedia) {
                navigator.mediaDevices.getDisplayMedia({
                    video: true
                }).then(screenStream => {
                    navigator.mediaDevices.getUserMedia({audio:true}).then(function(mic) {
                        screenStream.addTrack(mic.getTracks()[0]);

                        config.onMediaCaptured(screenStream);

                        addStreamStopListener(screenStream, function() {
                            btnStart.onclick();
                        });

                        setVideoURL(screenStream, true);
                    });
                }).catch(function(error) {
                    config.onMediaCapturingFailed(error);
                });
            } else {
                var error = 'getDisplayMedia API are not supported in this browser.';
                config.onMediaCapturingFailed(error);
                alert(error);
            }
        }
    </script>
    
    <script>
        var recordingPlayer      = media_element.media
        var recordingMedia       = document.querySelector('#media-sound')
        var mediaContainerFormat = document.querySelector('#media-format')
        var btnStart             = document.querySelector('#btn-start')

        window.onbeforeunload = function() {
            btnStart.disabled = false
            recordingMedia.disabled = false
            mediaContainerFormat.disabled = false
        }


        btnStart.onclick = function(event) {
            event.preventDefault()
            
            if (btnStart.innerHTML === 'Stop') { // Stop button
                btnStart.innerHTML = 'Start'
                btnStart.classList.replace('btn-danger', 'btn-success')

                function stopStream() {
                    if (btnStart.stream && btnStart.stream.stop) {
                        btnStart.stream.stop()
                        btnStart.stream = null
                    }

                    media_bitrate = null
                    recordingPlayer.parentNode.parentNode.querySelector('h2').innerHTML = 'Recording stopped' +
                        '<br>Size: ' + formatBytes(btnStart.recordRTC.getBlob().size)
                }

                if (btnStart.recordRTC) {
                    btnStart.recordRTC.stopRecording(function(url) {
                        if (btnStart.blobs && btnStart.blobs.length) {
                            const blob = new File(
                                btnStart.blobs,
                                makeFileName(fileExtension),
                                {type: mimeType}
                            )
                            
                            btnStart.recordRTC.getBlob = function() {
                                return blob
                            }

                            url = URL.createObjectURL(blob)
                        }

                        btnStart.recordingEndedCallback(url)
                        downloadVideo(btnStart.recordRTC)
                        stopStream()
                    })
                }

                return
            }
            
            btnStart.innerHTML = 'Stop'
            // btnStart.classList.replace('btn-success', 'btn-danger')

            if (!event) return
            
            btnStart.disabled = true

            var commonConfig = {
                onMediaCaptured: function(stream) {
                    btnStart.stream = stream
                    btnStart.mediaCapturedCallback()
                    btnStart.innerHTML = 'Stop'
                    btnStart.disabled = false
                    recordingPlayer.parentNode.parentNode.querySelector('h2').innerHTML = 'Recording in progress'
                },

                onMediaStopped: function() {
                    btnStart.innerHTML = 'Start'
                    btnStart.disabled = btnStart.disableStateWaiting
                    recordingPlayer.parentNode.parentNode.querySelector('h2').innerHTML = 'Recording inactive'
                },

                onMediaCapturingFailed: function(error) {
                    console.error('onMediaCapturingFailed:', error)

                    if (error.toString().indexOf('no audio or video tracks available') !== -1) {
                        alert('RecordRTC failed to start because there are no audio or video tracks available.');
                    }
                    
                    if (error.name === 'PermissionDeniedError' && DetectRTC.browser.name === 'Firefox') {
                        alert('Firefox requires version >= 52. Firefox also requires HTTPs.');
                    }

                    recordingPlayer.parentNode.parentNode.querySelector('h2').innerHTML = 'Recording failed' +
                        '<br>' + error
                    commonConfig.onMediaStopped()
                }
            };

            const check_conditions = [mediaContainerFormat.value, mimeType, fileExtension, recorderType, type]
            const checks = [
                ['h264',        'video/mpeg',                   'mp4'],
                ['h264',        'video/webm\;codecs=h264',      'mp4'],
                ['mp4',         'video/mpeg',                   'mp4'],
                ['mp4',         'video/webm\;codecs=h264',      'mp4'],
                ['mkv',         'video/x-matroska;codecs=avc1', 'mkv'],
                ['whammy',      'video/webm',                   'webm', WhammyRecorder,      'video'],
                ['WebAssembly', 'video/webm',                   'webm', WebAssemblyRecorder, 'video'],
                ['vp8',         'video/webm\;codecs=vp8',       'webm', null,                'video'],
                ['vp9',         'video/webm\;codecs=vp9',       'webm', null,                'video'],
                ['default',     'video/webm',                   'webm', null,                'video'],
                ['gif',         'image/gif',                    'gif',  GifRecorder,         'gif'  ],
                ['pcm',         'audio/wav',                    'wav',  StereoAudioRecorder, 'audio'],
                ['opus',        'audio/webm',                   'webm', null,                'audio'],
                ['opus',        'audio/ogg; codecs=opus',       'ogg',  null,                'audio'],
                ['ogg',         'audio/webm',                   'webm', null,                'audio'],
                ['ogg',         'audio/ogg; codecs=opus',       'ogg',  null,                'audio'],
            ]

            checks.forEach(function (check) {
                if (mediaContainerFormat.value === check[0] && isMimeTypeSupported(check[1])) {
                    console.log('>>>>>>>>>', mediaContainerFormat.value, check[3])
                    if (check.length > 1) mimeType      = check[1]
                    if (check.length > 2) fileExtension = check[2]
                    if (check.length > 3) recorderType  = check[3]
                    if (check.length > 4) type          = check[4]
                }
            })

            console.log('ext', mediaContainerFormat.value, fileExtension)

            if (recordingMedia.value === 'without-sound') {
                captureScreen(commonConfig);
            } else if (recordingMedia.value === 'with-sound') {
                captureAudioPlusScreen(commonConfig);
            }

            btnStart.mediaCapturedCallback = function () {
                var options = {
                    type: type,
                    mimeType: mimeType,
                    disableLogs: params.disableLogs || false,
                    getNativeBlob: true, // enable it for longer recordings,
                    ignoreMutedMedia: true,
                    video: recordingPlayer
                };

                if (recorderType) {
                    options.recorderType = recorderType;

                    if (recorderType == WhammyRecorder || recorderType == GifRecorder || recorderType == WebAssemblyRecorder) {
                        options.canvas = options.video = {
                            width: defaultWidth || 320,
                            height: defaultHeight || 240
                        }
                    }
                }

                if (media_bitrate) {
                    options.media_bitrate = media_bitrate;
                }

                btnStart.recordingEndedCallback = function(url) {
                    setVideoURL(url)
                }

                btnStart.recordRTC = RecordRTC(btnStart.stream, options)
                btnStart.recordRTC.startRecording()
            }
        } // END btnStart.onclick


        function setBitrate() {
            var select = document.querySelector('#media-bitrate');
            var value = select.value;

            media_bitrate = (value == 'default') ? null
                : parseInt(value)
        } // END function setBitrate


        function getFrameRates(mediaConstraints) {
            var select = document.querySelector('#media-framerate')
            var value = select.value

            if (!!mediaConstraints.video || value == 'default') return mediaConstraints

            value = parseInt(value)

            if (DetectRTC.browser.name === 'Firefox') {
                mediaConstraints.video.frameRate = value;
                return mediaConstraints;
            }

            if (!mediaConstraints.video.mandatory) {
                mediaConstraints.video.mandatory = {};
                mediaConstraints.video.optional = [];
            }

            if (recordingMedia.value.toString().toLowerCase().indexOf('screen') != -1) {
                mediaConstraints.video.mandatory.maxFrameRate = value;
            } else {
                mediaConstraints.video.mandatory.minFrameRate = value;
            }

            return mediaConstraints;
        } // END function getFrameRates




        function addEventListenerToUploadLocalStorageItem(selector, arr, callback) {
            arr.forEach(function(event) {
                document.querySelector(selector).addEventListener(event, callback, false);
            })
        } // END function addEventListenerToUploadLocalStorageItem


        function getVideoResolutions(mediaConstraints) {
            var select = document.querySelector('#media-resolution');
            var value = select.value;

            if (!mediaConstraints.video || value == 'default') return mediaConstraints

            value = value.split('x');
            if (value.length != 2) return mediaConstraints

            if (DetectRTC.browser.name === 'Firefox') {
                mediaConstraints.video.width = defaultWidth;
                mediaConstraints.video.height = defaultHeight;
                return mediaConstraints;
            }

            if (!mediaConstraints.video.mandatory) {
                mediaConstraints.video.mandatory = {};
                mediaConstraints.video.optional = [];
            }

            defaultWidth = parseInt(value[0]);
            defaultHeight = parseInt(value[1]);

            if (recordingMedia.value.toString().toLowerCase().indexOf('screen') != -1) {
                mediaConstraints.video.mandatory.maxWidth = defaultWidth;
                mediaConstraints.video.mandatory.maxHeight = defaultHeight;
            } else {
                mediaConstraints.video.mandatory.minWidth = defaultWidth;
                mediaConstraints.video.mandatory.minHeight = defaultHeight;
            }

            return mediaConstraints;
        } // END function getVideoResolutions


        function captureUserMedia(mediaConstraints, successCallback, errorCallback) {
            if (mediaConstraints.video == true) {
                mediaConstraints.video = {}
            }

            setBitrate()

            mediaConstraints = getVideoResolutions(mediaConstraints)
            mediaConstraints = getFrameRates(mediaConstraints)

            navigator.mediaDevices.getUserMedia(mediaConstraints).then(function(stream) {
                successCallback(stream);

                setVideoURL(stream, true);
            }).catch(function(error) {
                if (error && (error.name === 'ConstraintNotSatisfiedError' || error.name === 'OverconstrainedError')) {
                    alert('Your browser does not support the selected resolution or frame-rates. \n\nPlease select "default".');
                } else if (error && error.message) {
                    alert(error.message);
                } else {
                    alert('Unable to make getUserMedia request. Please check browser console logs.');
                }

                errorCallback(error);
            });
        } // END function captureUserMedia

        
        function setMediaContainerFormat(supported_options) {
            var options = Array.prototype.slice.call(
                mediaContainerFormat.querySelectorAll('option')
            )

            var localStorageItem = localStorage.getItem('media-format')

            supported_options.forEach(function (option) {
                var op = document.createElement('option')
                op.innerHTML = option
                op.value = option

                if (localStorageItem && supported_options.indexOf(localStorageItem) != -1) {
                    op.selected = (op.innerHTML == localStorageItem)
                }

                mediaContainerFormat.appendChild(op)
            })
        } // END function setMediaContainerFormat
        

        initFormats()

        setGetFromLocalStorage(
            ['#media-resolution', '#media-framerate', '#media-bitrate', '#media-sound', '#media-format']
        )


        if (typeof MediaRecorder === 'undefined' && (DetectRTC.browser.name === 'Edge' || DetectRTC.browser.name === 'Safari')) {
            console.warn('MediaRecorder API and webp are not supported in ' + DetectRTC.browser.name + '.');

            recordingMedia.innerHTML = '<option value="with-sound">With Sound</option>';
            setMediaContainerFormat(['pcm'])
        }
    </script>

    <script> // Endings
        function getFailureReport() {
            var info = 'RecordRTC failed.\n\n' + stringify(DetectRTC.browser) + '\n\n' + DetectRTC.osName + ' ' + DetectRTC.osVersion + '\n';

            if (typeof recorderType !== 'undefined' && recorderType) {
                info += '\nrecorderType: ' + recorderType.name;
            }

            if (typeof mimeType !== 'undefined') {
                info += '\nmimeType: ' + mimeType;
            }

            Array.prototype.slice.call(document.querySelectorAll('select')).forEach(function(select) {
                info += '\n' + (select.id || select.className) + ': ' + select.value;
            });

            if (btnStart.recordRTC) {
                info += '\n\ninternal-recorder: ' + btnStart.recordRTC.getInternalRecorder().name;
                
                if (btnStart.recordRTC.getInternalRecorder().getAllStates) {
                    info += '\n\nrecorder-states: ' + btnStart.recordRTC.getInternalRecorder().getAllStates();
                }
            }

            if (btnStart.stream) {
                info += '\n\naudio-tracks: ' + getTracks(btnStart.stream, 'audio').length;
                info += '\nvideo-tracks: ' + getTracks(btnStart.stream, 'video').length;
                info += '\nstream-active? ' + !!btnStart.stream.active;

                btnStart.stream.getTracks().forEach(function(track) {
                    info += '\n' + track.kind + '-track-' + (track.label || track.id) + ': (enabled: ' + !!track.enabled + ', readyState: ' + track.readyState + ', muted: ' + !!track.muted + ')';

                    if (track.getConstraints && Object.keys(track.getConstraints()).length) {
                        info += '\n' + track.kind + '-track-getConstraints: ' + stringify(track.getConstraints());
                    }

                    if (track.getSettings && Object.keys(track.getSettings()).length) {
                        info += '\n' + track.kind + '-track-getSettings: ' + stringify(track.getSettings());
                    }
                });
            }

            if (timeSlice && btnStart.recordRTC) {
                info += '\ntimeSlice: ' + timeSlice;

                if (btnStart.recordRTC.getInternalRecorder().getArrayOfBlobs) {
                    var blobSizes = [];
                    btnStart.recordRTC.getInternalRecorder().getArrayOfBlobs().forEach(function(blob) {
                        blobSizes.push(blob.size);
                    });
                    info += '\nblobSizes: ' + blobSizes;
                }
            } else if (btnStart.recordRTC && btnStart.recordRTC.getBlob()) {
                info += '\n\nblobSize: ' + formatBytes(btnStart.recordRTC.getBlob().size);
            }

            if (btnStart.recordRTC && btnStart.recordRTC.getInternalRecorder() && btnStart.recordRTC.getInternalRecorder().getInternalRecorder && btnStart.recordRTC.getInternalRecorder().getInternalRecorder()) {
                info += '\n\ngetInternalRecorder: ' + mediaRecorderToStringify(btnStart.recordRTC.getInternalRecorder().getInternalRecorder());
            }

            return info;
        } // END function getFailureReport


        function downloadVideo(recordRTC) {
            if (!recordRTC.getBlob().size) {
                var info = getFailureReport()
                console.error('blob', recordRTC.getBlob())
                console.error('recordrtc instance', recordRTC)
                console.error('report', info)

                if (mediaContainerFormat.value !== 'default') {
                    alert('Recording failed using ' + mediaContainerFormat.value + '. Please choose "default" option from the drop down and record again.');
                } else {
                    alert('Recording failed. Unexpected issue. Please see console log.');
                }

                if (mediaContainerFormat.value !== 'vp9' && DetectRTC.browser.name === 'Chrome') {
                    alert('Please record using VP9 format.');
                }
            }

            var fileName = makeFileName(fileExtension);

            document.querySelector('#btn-download').style.display = ''
            document.querySelector('#btn-upload').style.display = ''

            document.querySelector('#btn-download').onclick = function(event) {
                event.preventDefault()

                if (!recordRTC) return alert('No recording found.')

                var file = new File(
                    [recordRTC.getBlob()],
                    fileName,
                    {type: mimeType}
                )

                invokeSaveAsDialog(file, file.name)
            }

            // upload to PHP server
            if (isMyOwnDomain()) {
                document.querySelector('#btn-upload').disabled = true;
                document.querySelector('#btn-upload').style.display = 'none';
            } else {
                document.querySelector('#btn-upload').disabled = false;
            }
            
            document.querySelector('#btn-upload').onclick = function(event) {
                event.preventDefault()

                if (isMyOwnDomain()) {
                    alert('PHP Upload is not available on this domain.');
                    return;
                }

                if (!recordRTC) return alert('No recording found.')

                this.disabled = true;

                var button = this

                uploadVideo(fileName, recordRTC, function(progress, fileURL) {
                    if (progress === 'ended') {
                        button.disabled = false;
                        button.innerHTML = 'Click to download from server';
                        button.onclick = function(event) {
                            event.preventDefault()
                            saveUrlToDisk(fileURL, fileName);
                        };

                        setVideoURL(fileURL);

                        var html = 'Uploaded to PHP.<br>Download using below link:<br>';
                        html += '<a href="'+fileURL+'" download="'+fileName+'" style="color: yellow; display: block; margin-top: 15px;">'+fileName+'</a>';
                        recordingPlayer.parentNode.parentNode.querySelector('h2').innerHTML = html;
                        return;
                    }
                    button.innerHTML = progress;
                    recordingPlayer.parentNode.parentNode.querySelector('h2').innerHTML = progress;
                });
            };
        } // END function downloadVideo


        function uploadVideo(fileName, recordRTC, callback) {
            var blob = recordRTC instanceof Blob ? recordRTC : recordRTC.getBlob();
            
            blob = new File([blob], makeFileName(fileExtension), {
                type: mimeType
            });

            // create FormData
            var formData = new FormData();
            formData.append('video-filename', fileName);
            formData.append('video-blob', blob);

            callback('Uploading recorded-file to server.');

            // var upload_url = 'https://your-domain.com/files-uploader/';
            var upload_url = 'RecordRTC-to-PHP/save.php';

            // var upload_directory = upload_url;
            var upload_directory = 'RecordRTC-to-PHP/uploads/';

            makeXMLHttpRequest(upload_url, formData, function(progress) {
                if (progress !== 'upload-ended') {
                    callback(progress);
                    return;
                }

                callback('ended', upload_directory + fileName);
            });
        } // END function uploadVideo


        function makeXMLHttpRequest(url, data, callback) {
            var request = new XMLHttpRequest();
            request.onreadystatechange = function() {
                if (request.readyState == 4 && request.status == 200) {
                    if (request.responseText === 'success') {
                        callback('upload-ended');
                        return;
                    }
                }
            };

            request.upload.onloadstart = function() {
                callback('Upload started...');
            };

            request.upload.onprogress = function(event) {
                callback('Upload Progress: ' + Math.round(event.loaded / event.total * 100) + "%");
            };

            request.upload.onload = function() {
                callback('progress-about-to-end');
            };

            request.upload.onload = function() {
                callback('Getting File URL...');
            };

            request.upload.onerror = function(error) {
                callback('Failed to upload to server');
            };

            request.upload.onabort = function(error) {
                callback('Upload aborted.');
            };

            request.open('POST', url);
            request.send(data);
        } // END function makeXMLHttpRequest


        function saveUrlToDisk(fileUrl, fileName) {
            var hyperlink = document.createElement('a')
            hyperlink.href = fileUrl
            hyperlink.target = '_blank'
            hyperlink.download = fileName || fileUrl

            var doc = (document.body || document.documentElement)
            doc.appendChild(hyperlink)

            hyperlink.onclick = function(event) {
                event.preventDefault()
                doc.removeChild(hyperlink)
                window.URL.revokeObjectURL(hyperlink.href)
            }

            var mouseEvent = new MouseEvent('click', {
                view: window,
                bubbles: true,
                cancelable: true
            })

            hyperlink.dispatchEvent(mouseEvent)
        } // END function saveUrlToDisk


        function setVideoURL(arg, forceNonImage) {
            var parentNode = recordingPlayer.parentNode
            parentNode.removeChild(recordingPlayer)
            parentNode.innerHTML = ''

            var elem = (type == 'gif' && !forceNonImage) ? 'img'
                : (type == 'audio') ? 'audio'
                : 'video'

            recordingPlayer = document.createElement(elem);
            recordingPlayer.muted = (arg instanceof MediaStream)

            recordingPlayer.addEventListener('loadedmetadata', function() {
                if (navigator.userAgent.toLowerCase().indexOf('android') == -1) return
            }, false)

            recordingPlayer.poster = ''

            if (arg instanceof MediaStream) {
                recordingPlayer.srcObject = arg;
            } else {
                recordingPlayer.src = getURL(arg);
            }

            if (typeof recordingPlayer.play === 'function') recordingPlayer.play()

            recordingPlayer.addEventListener('ended', function() {
                if (arg instanceof MediaStream) {
                    recordingPlayer.srcObject = arg;
                } else {
                    recordingPlayer.src = getURL(arg);
                }
            })

            parentNode.appendChild(recordingPlayer)
        } // END function setVideoURL
    </script>

    <script src="assets/js/cors_upload.js"></script>
</body>
</html>
